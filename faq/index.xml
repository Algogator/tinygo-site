<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FAQ on TinyGo - Go on Microcontrollers and WASM</title>
    <link>https://tinygo.org/faq/</link>
    <description>Recent content in FAQ on TinyGo - Go on Microcontrollers and WASM</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tinygo.org/faq/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>What is TinyGo exactly?</title>
      <link>https://tinygo.org/faq/what-is-tinygo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/what-is-tinygo/</guid>
      <description>A new compiler and a new runtime implementation.
Specifically:
 A new compiler using (mostly) the standard library to parse Go programs and using LLVM to optimize the code and generate machine code for the target architecture.
 A new runtime library that implements some compiler intrinsics, like a memory allocator, a scheduler, and operations on strings. Also, some packages that are strongly connected to the runtime like the sync package and the reflect package have been or will be re-implemented for use with this new compiler.</description>
    </item>
    
    <item>
      <title>Why a new compiler?</title>
      <link>https://tinygo.org/faq/why-a-new-compiler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/why-a-new-compiler/</guid>
      <description>Why not modify the existing compiler to produce binaries for microcontrollers?
There are several reasons for this:
 The standard Go compiler (gc) does not support instruction sets as used on microcontrollers:
 The Thumb instruction set is unsupported, but it should be possible to add support for it as it already has an ARM backend. The AVR instruction set (as used in the Arduino Uno) is unsupported and unlikely to be ever supported.</description>
    </item>
    
    <item>
      <title>Why Go instead of Rust?</title>
      <link>https://tinygo.org/faq/why-go-instead-of-rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/why-go-instead-of-rust/</guid>
      <description>Rust is another &amp;ldquo;new&amp;rdquo; and safer language that is now made ready for embedded processors. There is a fairly active community around it.
However, apart from personal language preference, Go has a few advantages:
 Subjective, but in general Go is easier to learn. Rust is in general far more complicated than Go, with difficult-to-grasp ownership rules, traits, generics, etc. Go prides itself on being a simple and slightly dumb language, sacrificing some expressiveness for readability.</description>
    </item>
    
    <item>
      <title>What about the ESP8266/ESP32?</title>
      <link>https://tinygo.org/faq/what-about-esp8266-esp32/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/what-about-esp8266-esp32/</guid>
      <description>As of February 2019 there is now an official project from Espressif to add the Xtensa chip architecture to LLVM.
For the discussion of this see this forum thread.
The repository that contains the Xtensa fork of LLVM is located at https://github.com/espressif/llvm-xtensa
The repository that contains the Xtensa fork of Clang is located at https://github.com/espressif/clang-xtensa.
It is not yet in a usable state, but once it is we will start the process of supporting it in TinyGo.</description>
    </item>
    
  </channel>
</rss>