<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on TinyGo - Go on Microcontrollers and WASM</title>
    <link>https://tinygo.org/</link>
    <description>Recent content in Home on TinyGo - Go on Microcontrollers and WASM</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Apr 2019 11:41:45 +0200</lastBuildDate>
    
	<atom:link href="https://tinygo.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux</title>
      <link>https://tinygo.org/getting-started/linux/</link>
      <pubDate>Mon, 15 Apr 2019 11:41:45 +0200</pubDate>
      
      <guid>https://tinygo.org/getting-started/linux/</guid>
      <description>This page has information on how to install and use TinyGo on Ubuntu, as well as other Linux distros.
If you want to use TinyGo to compile your own or sample code, you can install the release version directly on your machine by following the &amp;ldquo;Quick Install&amp;rdquo; instructions below.
You can instead install the full source code to the TinyGo compiler itself, generally for people who wish to contribute to the project or want to build the compiler from sources.</description>
    </item>
    
    <item>
      <title>macOS</title>
      <link>https://tinygo.org/getting-started/macos/</link>
      <pubDate>Mon, 15 Apr 2019 11:41:45 +0200</pubDate>
      
      <guid>https://tinygo.org/getting-started/macos/</guid>
      <description>This page has information on how to install and use TinyGo on macOS.
If you want to use TinyGo to compile your own or sample code, you can install the release version directly on your machine by following the &amp;ldquo;Quick Install&amp;rdquo; instructions below.
You can also install the full source code to the TinyGo compiler itself, generally for people who wish to contribute to the project or want to build the compiler from sources directly.</description>
    </item>
    
    <item>
      <title>Basic command examples</title>
      <link>https://tinygo.org/usage/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/usage/basic/</guid>
      <description>Here will go some basic examples of using TinyGo in the most common scenarios.
Building &amp;ldquo;Hello, World&amp;rdquo; program for WebAssembly To build the WASM example, run the following command:
tinygo build -o wasm.wasm -target=wasm examples/wasm/export  See the WebAssembly page for more information on executing the compiled WebAssembly.
Building/flashing a &amp;ldquo;blink&amp;rdquo; program for micro:bit To build and then flash a basic blink program for a micro:bit board:
 Plug your micro:bit into your computer&amp;rsquo;s USB port.</description>
    </item>
    
    <item>
      <title>Differences from Go</title>
      <link>https://tinygo.org/compiler-internals/differences-from-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/differences-from-go/</guid>
      <description>A whole program is compiled in a single step, without intermediate linking. This makes incremental development much slower for large programs but enables far more optimization opportunities. In the future, an option should be added for incremental compilation during edit-compile-test cycles. Interfaces are always represented as a {typecode, value} pair. Unlike Go https://research.swtch.com/interfaces, TinyGo will not precompute a list of function pointers for fast interface method calls. Instead, all interface method calls are looked up where they are used.</description>
    </item>
    
    <item>
      <title>Heap allocation</title>
      <link>https://tinygo.org/compiler-internals/heap-allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/heap-allocation/</guid>
      <description>Many operations in Go rely on heap allocation. Some of these heap allocations are optimized away, but not all of them. Also, TinyGo does not yet contain a garbage collector so heap allocation must be avoided whenever possible outside of initialization code.
These operations currently do heap allocations:
 Taking the pointer of a local variable. This will result in a heap allocation, unless the compiler can see the resulting pointer never escapes.</description>
    </item>
    
    <item>
      <title>Subcommands</title>
      <link>https://tinygo.org/usage/subcommands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/usage/subcommands/</guid>
      <description>TinyGo tries to be similar to the main go command in usage. It consists of the following main subcommands:
build Compile the given program. The output binary is specified using the -o parameter. The generated file type depends on the extension:
.o Create a relocatable object file. You can use this option if you don&amp;rsquo;t want to use the TinyGo build system or want to do other custom things.</description>
    </item>
    
    <item>
      <title>What is TinyGo exactly?</title>
      <link>https://tinygo.org/faq/what-is-tinygo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/what-is-tinygo/</guid>
      <description>A new compiler and a new runtime implementation.
Specifically:
 A new compiler using (mostly) the standard library to parse Go programs and using LLVM to optimize the code and generate machine code for the target architecture.
 A new runtime library that implements some compiler intrinsics, like a memory allocator, a scheduler, and operations on strings. Also, some packages that are strongly connected to the runtime like the sync package and the reflect package have been or will be re-implemented for use with this new compiler.</description>
    </item>
    
    <item>
      <title>Windows</title>
      <link>https://tinygo.org/getting-started/windows/</link>
      <pubDate>Mon, 15 Apr 2019 11:41:45 +0200</pubDate>
      
      <guid>https://tinygo.org/getting-started/windows/</guid>
      <description>This page has information on how to install and use TinyGo on Windows 10.
Quick Install If you want to use TinyGo to compile your own or sample code, you should be able to install the release version directly on your machine using Windows Subsystem for Linux (WSL) by following the &amp;ldquo;Quick Install&amp;rdquo; instructions on the Linux page located here.
Docker Install The other option is to use the Docker image.</description>
    </item>
    
    <item>
      <title>Arduino Uno</title>
      <link>https://tinygo.org/microcontrollers/arduino-uno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/arduino-uno/</guid>
      <description>The Arduino Uno is based on the AVR ATmega328p microcontroller.
Note: the AVR backend of LLVM is still experimental so you may encounter bugs.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES Not yet   I2C YES YES   ADC YES YES   PWM YES YES    Flashing AVRDude Programs are loaded onto the Arduino Uno using the avrdude command line utility program.</description>
    </item>
    
    <item>
      <title>BBC micro:bit</title>
      <link>https://tinygo.org/microcontrollers/bbc-microbit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/bbc-microbit/</guid>
      <description>The BBC micro:bit is a tiny programmable computer designed for learning. It is based on the Nordic Semiconductor nRF51822 ARM Cortex MO chip.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM Software support Not yet    Flashing DAPLink The micro:bit comes with the DAPLink bootloader already installed.</description>
    </item>
    
    <item>
      <title>Bluepill</title>
      <link>https://tinygo.org/microcontrollers/bluepill/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/bluepill/</guid>
      <description>The Bluepill is a popular, ultra-cheap and compact ARM development board based on the ST Micro STM32F103C8 SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing OpenOCD Programs are loaded onto the Bluepill with a separate hardware programmer such as the STLink v2 board, using the openocd command line utility program to perform the board flashing.</description>
    </item>
    
    <item>
      <title>Circuit Playground Express</title>
      <link>https://tinygo.org/microcontrollers/circuit-playground-express/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/circuit-playground-express/</guid>
      <description>The Adafruit Circuit Playground Express is small ARM development board based on the Atmel SAMD21 family of processors. It has several built-in devices such as WS2812 &amp;ldquo;NeoPixel&amp;rdquo; LEDs, buttons, an accelerometer, and some other sensors.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES YES   PWM YES YES    Flashing UF2 The Circuit Playground Express comes with the UF2 bootloader already installed.</description>
    </item>
    
    <item>
      <title>Datatypes</title>
      <link>https://tinygo.org/compiler-internals/datatypes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/datatypes/</guid>
      <description>TinyGo uses a different representation for some data types than standard Go.
string A string is encoded as a {ptr, len} tuple. The type is actually defined in the runtime as runtime._string, in src/runtime/string.go. That file also contains some compiler intrinsics for dealing with strings and UTF-8.
slice A slice is encoded as a {ptr, len, cap} tuple. There is no runtime definition of it as slices are a generic type and the pointer type is different for each slice.</description>
    </item>
    
    <item>
      <title>Digispark</title>
      <link>https://tinygo.org/microcontrollers/digispark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/digispark/</guid>
      <description>The Digispark is an ATtiny85 based microcontroller development board similar to the Arduino line, only cheaper, smaller, and a bit less powerful.
There is very limited support at the moment for this board.
Note: the AVR backend of LLVM is still experimental so you may encounter bugs.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES Not yet   SPI Requires software Not yet   I2C Requires software Not yet   ADC YES Not yet   PWM ?</description>
    </item>
    
    <item>
      <title>Important Build Options</title>
      <link>https://tinygo.org/usage/important-options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/usage/important-options/</guid>
      <description>There are a few flags to control how binaries are built:
 -o Output filename, see the build command.
 -target Select the target you want to use. Leave it empty to compile for the host. This switch also configures the emulator, flash tool and debugger to use so you don&amp;rsquo;t have to fiddle with those options. Read [supported targets]() for a list of supported targets. Example targets:
 wasm WebAssembly target.</description>
    </item>
    
    <item>
      <title>ItsyBitsy M0</title>
      <link>https://tinygo.org/microcontrollers/itsybitsy-m0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/itsybitsy-m0/</guid>
      <description>The Adafruit ItsyBitsy M0 is very compact ARM development board based on the Atmel SAMD21 family of SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES YES   PWM YES YES    Flashing UF2 The ItsyBitsy M0 comes with the UF2 bootloader already installed.</description>
    </item>
    
    <item>
      <title>PCA10031</title>
      <link>https://tinygo.org/microcontrollers/pca10031/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/pca10031/</guid>
      <description>The Nordic Semiconductor PCA10031 is a low-cost, versatile USB development dongle for wireless applications based on the Nordic Semiconductor nRF51422 chip using the nRF51 series SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES Not yet   I2C YES Not yet   ADC YES Not yet   PWM YES Not yet    Flashing nrfjprog/J-Link Programs are loaded onto the pca10031 board using the nrfjprog command line utility program.</description>
    </item>
    
    <item>
      <title>PCA10040</title>
      <link>https://tinygo.org/microcontrollers/pca10040/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/pca10040/</guid>
      <description>The Nordic Semiconductor PCA10040 is a single-board development kit for wireless applications based on the Nordic Semiconductor nRF52832 SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES YES   PWM YES YES    Flashing nrfjprog/J-Link Programs are loaded onto the pca10040 board using the nrfjprog command line utility program.</description>
    </item>
    
    <item>
      <title>PCA10056</title>
      <link>https://tinygo.org/microcontrollers/pca10056/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/pca10056/</guid>
      <description>The Nordic Semiconductor PCA10056 is a single-board development kit for wireless applications based on the Nordic Semiconductor nRF52840 SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing nrfjprog/J-Link Programs are loaded onto the pca10056 board using the nrfjprog command line utility program.</description>
    </item>
    
    <item>
      <title>STM32F4 Discovery</title>
      <link>https://tinygo.org/microcontrollers/stm32f4discovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/stm32f4discovery/</guid>
      <description>The STM32F4 Discovery is an ARM development board based on the ST Micro STM32F407 SoC.
It has an onboard LIS302DL or LIS3DSH accelerometer, MP45DT02 MEMS digital microphone, an CS43L22 audio DAC, 2 user buttons, and 4 user LEDs.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES Not yet   I2C YES Not yet   ADC YES Not yet   PWM YES Not yet    Flashing OpenOCD Programs are loaded onto the STM32F4 Discovery with the onboard STLink v2 hardware programmer, using the openocd command line utility program to perform the board flashing.</description>
    </item>
    
    <item>
      <title>The volatile keyword</title>
      <link>https://tinygo.org/compiler-internals/volatile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/volatile/</guid>
      <description>Go does not have the volatile keyword like C/C++. This keyword is unnecessary in most desktop use cases but is required for memory mapped I/O on microcontrollers and interrupt handlers. As a workaround, any variable of a type annotated with the //go:volatile pragma will be marked volatile. For example:
//go:volatile type volatileBool bool var isrFlag volatileBool  This is a workaround for a limitation in the Go language and should at some point be replaced with something else.</description>
    </item>
    
    <item>
      <title>Using WebAssembly</title>
      <link>https://tinygo.org/webassembly/webassembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/webassembly/webassembly/</guid>
      <description>You can call a JavaScript function from Go and call a Go function from WebAssembly:
package main // This calls a JS function from Go. func main() { println(&amp;quot;adding two numbers:&amp;quot;, add(2, 3)) // expecting 5 } // This function is imported from JavaScript, as it doesn&#39;t define a body. // You should define a function named &#39;main.add&#39; in the WebAssembly &#39;env&#39; // module from JavaScript. func add(x, y int) // This function is exported to JavaScript, so can be called using // exports.</description>
    </item>
    
    <item>
      <title>Why a new compiler?</title>
      <link>https://tinygo.org/faq/why-a-new-compiler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/why-a-new-compiler/</guid>
      <description>Why not modify the existing compiler to produce binaries for microcontrollers?
There are several reasons for this:
 The standard Go compiler (gc) does not support instruction sets as used on microcontrollers:
 The Thumb instruction set is unsupported, but it should be possible to add support for it as it already has an ARM backend. The AVR instruction set (as used in the Arduino Uno) is unsupported and unlikely to be ever supported.</description>
    </item>
    
    <item>
      <title>nRF52840-MDK</title>
      <link>https://tinygo.org/microcontrollers/nrf52840-mdk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/nrf52840-mdk/</guid>
      <description>The nRF52840-MDK is an open-source, micro development kit for IoT applications based on the Nordic Semiconductor nRF52840 SoC chip.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing OpenOCD Programs are loaded onto the nRF52840-MDK board using the openocd command line utility program.</description>
    </item>
    
    <item>
      <title>reel board</title>
      <link>https://tinygo.org/microcontrollers/reelboard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/reelboard/</guid>
      <description>The reel board is an evaluation board based on the Nordic Semiconductor nRF52840 SoC.
It is equipped with an Electrophoretic (electronic ink) Display (EPD), along with temperature, humidity, light, and accelerometer sensors, and Bluetooth connectivity.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing OpenOCD Programs are loaded onto the reelboard using the openocd command line utility program.</description>
    </item>
    
    <item>
      <title>Calling convention</title>
      <link>https://tinygo.org/compiler-internals/calling-convention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/calling-convention/</guid>
      <description>Go uses a stack-based calling convention and passes a pointer to the argument list as the first argument in the function. There were/are plans to switch to a register-based calling convention but they&amp;rsquo;re now on hold.
TinyGo, however, uses a register based calling convention. In fact it is somewhat compatible with the C calling convention but with a few quirks:
 Struct parameters are split into separate arguments, if the number of fields (after flattening recursively) is 3 or lower.</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://tinygo.org/getting-started/using-docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/getting-started/using-docker/</guid>
      <description>You can use our Docker image to be able to run the TinyGo compiler on your computer without having to install all the dependencies. Read on to learn how.
Installing docker pull tinygo/tinygo  Using The paths used here are automatically resolved by tinygo relative to the installation directory. For your own code, you will probably want to use absolute paths.
A docker container exists for easy access to the TinyGo CLI.</description>
    </item>
    
    <item>
      <title>Inline assembly</title>
      <link>https://tinygo.org/compiler-internals/inline-assembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/inline-assembly/</guid>
      <description>The device-specific packages like device/avr and device/arm provide Asm functions which you can use to write inline assembly:
arm.Asm(&amp;quot;wfi&amp;quot;)  You can also pass parameters to the inline assembly:
var result int32 arm.AsmFull(` lsls {value}, #1 str {value}, {result} `, map[string]interface{}{ &amp;quot;value&amp;quot;: 42, &amp;quot;result&amp;quot;: &amp;amp;result, }) println(&amp;quot;result:&amp;quot;, result)  In general, types are autodetected. That is, integer types are passed as raw registers and pointer types are passed as memory locations.</description>
    </item>
    
    <item>
      <title>Misc. Build Options</title>
      <link>https://tinygo.org/usage/misc-options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/usage/misc-options/</guid>
      <description>-no-debug Disable outputting debug symbols. This can be useful for WebAssembly, as there is no debugger for .wasm files yet and .wasm files are generally served directly. Avoiding debug symbols can have a big impact on generated binary size, reducing them by more than half. This is not necessary on microcontrollers because debugging symbols are not flashed to the microcontroller. Additionally, you will need it when you use tinygo gdb.</description>
    </item>
    
    <item>
      <title>Why Go instead of Rust?</title>
      <link>https://tinygo.org/faq/why-go-instead-of-rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/why-go-instead-of-rust/</guid>
      <description>Rust is another &amp;ldquo;new&amp;rdquo; and safer language that is now made ready for embedded processors. There is a fairly active community around it.
However, apart from personal language preference, Go has a few advantages:
 Subjective, but in general Go is easier to learn. Rust is in general far more complicated than Go, with difficult-to-grasp ownership rules, traits, generics, etc. Go prides itself on being a simple and slightly dumb language, sacrificing some expressiveness for readability.</description>
    </item>
    
    <item>
      <title>Harvard architectures (AVR)</title>
      <link>https://tinygo.org/compiler-internals/harvard-arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/harvard-arch/</guid>
      <description>The AVR architecture is a modified Harvard architecture, which means that flash and RAM live in different address spaces. In practice, this means that any given pointer may either point to RAM or flash, but this is not visible from the pointer itself.
To get TinyGo to work on the Arduino, which uses the AVR architecutre, all global variables (which include string constants!) are marked non-constant and thus are stored in RAM and all pointer dereferences assume that pointers point to RAM.</description>
    </item>
    
    <item>
      <title>Microcontroller Targets</title>
      <link>https://tinygo.org/compiler-internals/microcontrollers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/microcontrollers/</guid>
      <description>TinyGo was designed to run on microcontrollers, but the Go language wasn&amp;rsquo;t. This means there are a few challenges to writing Go code for microcontrollers.
Microcontrollers have very little RAM and execute code directly from flash. Also, constant globals are generally put in flash whenever possible. The Go language itself heavily relies on garbage collection so care must be taken to avoid dynamic memory allocation.
ARM ARM Cortex-M processors are well supported.</description>
    </item>
    
    <item>
      <title>Pipeline</title>
      <link>https://tinygo.org/compiler-internals/pipeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/pipeline/</guid>
      <description>Like most compilers, TinyGo is a compiler built as a pipeline of transformations that each translate an input to a simpler output version (also called lowering). However, most of these part are not in TinyGo itself. The frontend is mostly implemented by external Go libraries, and most optimizations and code generation is implemented by LLVM.
This is roughly the pipeline for TinyGo:
 Lexing, parsing, and typechecking is done by packages in the standard library and in the golang.</description>
    </item>
    
    <item>
      <title>What about the ESP8266/ESP32?</title>
      <link>https://tinygo.org/faq/what-about-esp8266-esp32/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/what-about-esp8266-esp32/</guid>
      <description>As of February 2019 there is now an official project from Espressif to add the Xtensa chip architecture to LLVM.
For the discussion of this see this forum thread.
The repository that contains the Xtensa fork of LLVM is located at https://github.com/espressif/llvm-xtensa
The repository that contains the Xtensa fork of Clang is located at https://github.com/espressif/clang-xtensa.
It is not yet in a usable state, but once it is we will start the process of supporting it in TinyGo.</description>
    </item>
    
  </channel>
</rss>