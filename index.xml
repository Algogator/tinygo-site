<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on TinyGo - Go on Microcontrollers and WASM</title>
    <link>https://tinygo.org/</link>
    <description>Recent content in Home on TinyGo - Go on Microcontrollers and WASM</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tinygo.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Requirements</title>
      <link>https://tinygo.org/getting-started/requirements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/getting-started/requirements/</guid>
      <description>These are the base requirements and enough for most (desktop) use.
 Go 1.11+ LLVM 7 (for example, from apt.llvm.org  Linking a binary needs an installed C compiler (cc). At the moment it expects GCC or a recent Clang.
ARM Cortex-M The Cortex-M family of microcontrollers is well supported, as it uses the stable ARM LLVM backend (which is even used in the propietary C compiler from ARM). Compiling to object code should be supported out of the box, but compiling the final binary and flashing it needs some extra tools.</description>
    </item>
    
    <item>
      <title>Differences from Go</title>
      <link>https://tinygo.org/compiler-internals/differences-from-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/differences-from-go/</guid>
      <description>A whole program is compiled in a single step, without intermediate linking. This makes incremental development much slower for large programs but enables far more optimization opportunities. In the future, an option should be added for incremental compilation during edit-compile-test cycles. Interfaces are always represented as a {typecode, value} pair. Unlike Go https://research.swtch.com/interfaces, TinyGo will not precompute a list of function pointers for fast interface method calls. Instead, all interface method calls are looked up where they are used.</description>
    </item>
    
    <item>
      <title>Heap allocation</title>
      <link>https://tinygo.org/compiler-internals/heap-allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/heap-allocation/</guid>
      <description>Many operations in Go rely on heap allocation. Some of these heap allocations are optimized away, but not all of them. Also, TinyGo does not yet contain a garbage collector so heap allocation must be avoided whenever possible outside of initialization code.
These operations currently do heap allocations:
 Taking the pointer of a local variable. This will result in a heap allocation, unless the compiler can see the resulting pointer never escapes.</description>
    </item>
    
    <item>
      <title>Installation</title>
      <link>https://tinygo.org/getting-started/installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/getting-started/installation/</guid>
      <description>Now that you have the requirements, now download the sources. This may take a while.
go get -u github.com/tinygo-org/tinygo  If you get an error like this::
/usr/local/go/pkg/tool/linux_amd64/link: running g++ failed: exit status 1 /usr/bin/ld: error: cannot find -lLLVM-7 cgo-gcc-prolog:58: error: undefined reference to &#39;LLVMVerifyFunction&#39; cgo-gcc-prolog:80: error: undefined reference to &#39;LLVMVerifyModule&#39; [...etc...]  Or like this::
../go-llvm/analysis.go:17:93: fatal error: llvm-c/Analysis.h: No such file or directory #include &amp;quot;llvm-c/Analysis.h&amp;quot; // If you are getting an error here read bindings/go/README.</description>
    </item>
    
    <item>
      <title>Subcommands</title>
      <link>https://tinygo.org/usage/subcommands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/usage/subcommands/</guid>
      <description>TinyGo tries to be similar to the main go command in usage. It consists of the following main subcommands:
build Compile the given program. The output binary is specified using the -o parameter. The generated file type depends on the extension:
.o Create a relocatable object file. You can use this option if you don&amp;rsquo;t want to use the TinyGo build system or want to do other custom things.</description>
    </item>
    
    <item>
      <title>What is TinyGo exactly?</title>
      <link>https://tinygo.org/faq/what-is-tinygo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/what-is-tinygo/</guid>
      <description>A new compiler and a new runtime implementation.
Specifically:
 A new compiler using (mostly) the standard library to parse Go programs and using LLVM to optimize the code and generate machine code for the target architecture.
 A new runtime library that implements some compiler intrinsics, like a memory allocator, a scheduler, and operations on strings. Also, some packages that are strongly connected to the runtime like the sync package and the reflect package have been or will be re-implemented for use with this new compiler.</description>
    </item>
    
    <item>
      <title>Arduino Uno</title>
      <link>https://tinygo.org/microcontrollers/arduino-uno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/arduino-uno/</guid>
      <description>The Arduino Uno is based on the AVR ATmega328p microcontroller.
Note: the AVR backend of LLVM is still experimental so you may encounter bugs.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES Not yet   I2C YES YES   ADC YES YES   PWM YES YES    Flashing AVRDude Programs are loaded onto the Arduino Uno using the avrdude command line utility program.</description>
    </item>
    
    <item>
      <title>BBC:Microbit</title>
      <link>https://tinygo.org/microcontrollers/bbc-microbit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/bbc-microbit/</guid>
      <description>The BBC micro:bit is a tiny programmable computer designed for learning. It is based on the Nordic Semiconductor nRF51822 ARM Cortex MO chip.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM Software support Not yet    Flashing OpenOCD Programs are loaded onto the BBC:Microbit using the openocd command line utility program.</description>
    </item>
    
    <item>
      <title>Bluepill</title>
      <link>https://tinygo.org/microcontrollers/bluepill/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/bluepill/</guid>
      <description>The Bluepill is a popular, ultra-cheap and compact ARM development board based on the ST Micro STM32F103C8 SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing OpenOCD Programs are loaded onto the Bluepill with a separate hardware programmer such as the STLink v2 board, using the openocd command line utility program to perform the board flashing.</description>
    </item>
    
    <item>
      <title>Circuit Playground Express</title>
      <link>https://tinygo.org/microcontrollers/circuit-playground-express/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/circuit-playground-express/</guid>
      <description>The Adafruit Circuit Playground Express is small ARM development board based on the Atmel SAMD21 family of processors. It has several built-in devices such as WS2812 &amp;ldquo;NeoPixel&amp;rdquo; LEDs, buttons, an accelerometer, and some other sensors.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES YES   PWM YES YES    Flashing UF2 The Circuit Playground Express comes with the UF2 bootloader already installed.</description>
    </item>
    
    <item>
      <title>Datatypes</title>
      <link>https://tinygo.org/compiler-internals/datatypes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/datatypes/</guid>
      <description>TinyGo uses a different representation for some data types than standard Go.
string A string is encoded as a {ptr, len} tuple. The type is actually defined in the runtime as runtime._string, in src/runtime/string.go. That file also contains some compiler intrinsics for dealing with strings and UTF-8.
slice A slice is encoded as a {ptr, len, cap} tuple. There is no runtime definition of it as slices are a generic type and the pointer type is different for each slice.</description>
    </item>
    
    <item>
      <title>Digispark</title>
      <link>https://tinygo.org/microcontrollers/digispark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/digispark/</guid>
      <description>The Digispark is an ATtiny85 based microcontroller development board similar to the Arduino line, only cheaper, smaller, and a bit less powerful.
There is very limited support at the moment for this board.
Note: the AVR backend of LLVM is still experimental so you may encounter bugs.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES Not yet   SPI Requires software Not yet   I2C Requires software Not yet   ADC YES Not yet   PWM ?</description>
    </item>
    
    <item>
      <title>Important Build Options</title>
      <link>https://tinygo.org/usage/important-options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/usage/important-options/</guid>
      <description>There are a few flags to control how binaries are built:
 -o Output filename, see the build command.
 -target Select the target you want to use. Leave it empty to compile for the host. This switch also configures the emulator, flash tool and debugger to use so you don&amp;rsquo;t have to fiddle with those options. Read [supported targets]() for a list of supported targets. Example targets:
 wasm WebAssembly target.</description>
    </item>
    
    <item>
      <title>ItsyBitsy M0</title>
      <link>https://tinygo.org/microcontrollers/itsybitsy-m0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/itsybitsy-m0/</guid>
      <description>The Adafruit ItsyBitsy M0 is very compact ARM development board based on the Atmel SAMD21 family of SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES YES   PWM YES YES    Flashing UF2 The ItsyBitsy M0 comes with the UF2 bootloader already installed.</description>
    </item>
    
    <item>
      <title>PCA10031</title>
      <link>https://tinygo.org/microcontrollers/pca10031/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/pca10031/</guid>
      <description>The Nordic Semiconductor PCA10031 is a low-cost, versatile USB development dongle for wireless applications based on the Nordic Semiconductor nRF51422 chip using the nRF51 series SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES Not yet   I2C YES Not yet   ADC YES Not yet   PWM YES Not yet    Flashing nrfjprog/J-Link Programs are loaded onto the pca10031 board using the nrfjprog command line utility program.</description>
    </item>
    
    <item>
      <title>PCA10040</title>
      <link>https://tinygo.org/microcontrollers/pca10040/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/pca10040/</guid>
      <description>The Nordic Semiconductor PCA10040 is a single-board development kit for wireless applications based on the Nordic Semiconductor nRF52832 SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES YES   PWM YES YES    Flashing nrfjprog/J-Link Programs are loaded onto the pca10040 board using the nrfjprog command line utility program.</description>
    </item>
    
    <item>
      <title>PCA10056</title>
      <link>https://tinygo.org/microcontrollers/pca10056/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/pca10056/</guid>
      <description>The Nordic Semiconductor PCA10056 is a single-board development kit for wireless applications based on the Nordic Semiconductor nRF52840 SoC.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing nrfjprog/J-Link Programs are loaded onto the pca10056 board using the nrfjprog command line utility program.</description>
    </item>
    
    <item>
      <title>The volatile keyword</title>
      <link>https://tinygo.org/compiler-internals/volatile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/volatile/</guid>
      <description>Go does not have the volatile keyword like C/C++. This keyword is unnecessary in most desktop use cases but is required for memory mapped I/O on microcontrollers and interrupt handlers. As a workaround, any variable of a type annotated with the //go:volatile pragma will be marked volatile. For example:
//go:volatile type volatileBool bool var isrFlag volatileBool  This is a workaround for a limitation in the Go language and should at some point be replaced with something else.</description>
    </item>
    
    <item>
      <title>Usage</title>
      <link>https://tinygo.org/getting-started/usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/getting-started/usage/</guid>
      <description>TinyGo should now be installed. Test it by running a test program:
tinygo run examples/test  Before anything can be built for a bare-metal target, you need to generate some files first:
make gen-device  This will generate register descriptions, interrupt vectors, and linker scripts for various devices. Also, you may need to re-run this command after updates, as some updates cause changes to the generated files.
Now you can run a blinky example.</description>
    </item>
    
    <item>
      <title>Using WebAssembly</title>
      <link>https://tinygo.org/webassembly/webassembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/webassembly/webassembly/</guid>
      <description>You can call a JavaScript function from Go and call a Go function from WebAssembly:
package main // This calls a JS function from Go. func main() { println(&amp;quot;adding two numbers:&amp;quot;, add(2, 3)) // expecting 5 } // This function is imported from JavaScript, as it doesn&#39;t define a body. // You should define a function named &#39;main.add&#39; in the WebAssembly &#39;env&#39; // module from JavaScript. func add(x, y int) // This function is exported to JavaScript, so can be called using // exports.</description>
    </item>
    
    <item>
      <title>Why a new compiler?</title>
      <link>https://tinygo.org/faq/why-a-new-compiler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/why-a-new-compiler/</guid>
      <description>Why not modify the existing compiler to produce binaries for microcontrollers?
There are several reasons for this:
 The standard Go compiler (gc) does not support instruction sets as used on microcontrollers:
 The Thumb instruction set is unsupported, but it should be possible to add support for it as it already has an ARM backend. The AVR instruction set (as used in the Arduino Uno) is unsupported and unlikely to be ever supported.</description>
    </item>
    
    <item>
      <title>nRF52840-MDK</title>
      <link>https://tinygo.org/microcontrollers/nrf52840-mdk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/nrf52840-mdk/</guid>
      <description>The nRF52840-MDK is an open-source, micro development kit for IoT applications based on the Nordic Semiconductor nRF52840 SoC chip.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing OpenOCD Programs are loaded onto the nRF52840-MDK board using the openocd command line utility program.</description>
    </item>
    
    <item>
      <title>reel board</title>
      <link>https://tinygo.org/microcontrollers/reelboard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/reelboard/</guid>
      <description>The reel board is an evaluation board based on the Nordic Semiconductor nRF52840 SoC.
It is equipped with an Electrophoretic (electronic ink) Display (EPD), along with temperature, humidity, light, and accelerometer sensors, and Bluetooth connectivity.
Interfaces    Interface Hardware Supported TinyGo Support     GPIO YES YES   UART YES YES   SPI YES YES   I2C YES YES   ADC YES Not yet   PWM YES Not yet    Flashing OpenOCD Programs are loaded onto the reelboard using the openocd command line utility program.</description>
    </item>
    
    <item>
      <title>Calling convention</title>
      <link>https://tinygo.org/compiler-internals/calling-convention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/calling-convention/</guid>
      <description>Go uses a stack-based calling convention and passes a pointer to the argument list as the first argument in the function. There were/are plans to switch to a register-based calling convention but they&amp;rsquo;re now on hold.
TinyGo, however, uses a register based calling convention. In fact it is somewhat compatible with the C calling convention but with a few quirks:
 Struct parameters are split into separate arguments, if the number of fields (after flattening recursively) is 3 or lower.</description>
    </item>
    
    <item>
      <title>Inline assembly</title>
      <link>https://tinygo.org/compiler-internals/inline-assembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/inline-assembly/</guid>
      <description>The device-specific packages like device/avr and device/arm provide Asm functions which you can use to write inline assembly:
arm.Asm(&amp;quot;wfi&amp;quot;)  You can also pass parameters to the inline assembly:
var result int32 arm.AsmFull(` lsls {value}, #1 str {value}, {result} `, map[string]interface{}{ &amp;quot;value&amp;quot;: 42, &amp;quot;result&amp;quot;: &amp;amp;result, }) println(&amp;quot;result:&amp;quot;, result)  In general, types are autodetected. That is, integer types are passed as raw registers and pointer types are passed as memory locations.</description>
    </item>
    
    <item>
      <title>Misc. Build Options</title>
      <link>https://tinygo.org/usage/misc-options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/usage/misc-options/</guid>
      <description>-no-debug Disable outputting debug symbols. This can be useful for WebAssembly, as there is no debugger for .wasm files yet and .wasm files are generally served directly. Avoiding debug symbols can have a big impact on generated binary size, reducing them by more than half. This is not necessary on microcontrollers because debugging symbols are not flashed to the microcontroller. Additionally, you will need it when you use tinygo gdb.</description>
    </item>
    
    <item>
      <title>Using TinyGo with Docker</title>
      <link>https://tinygo.org/getting-started/using-docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/getting-started/using-docker/</guid>
      <description>You can use our Docker image to be able to run the TinyGo compiler on your computer without having to install all the dependencies. Read on to learn how.
Installing docker pull tinygo/tinygo  Using A docker container exists for easy access to the TinyGo CLI. For example, to compile wasm.wasm for the WebAssembly example, from the root of the repository:
docker run --rm -v $(pwd):/src tinygo/tinygo tinygo build -o /src/wasm.</description>
    </item>
    
    <item>
      <title>Why Go instead of Rust?</title>
      <link>https://tinygo.org/faq/why-go-instead-of-rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/why-go-instead-of-rust/</guid>
      <description>Rust is another &amp;ldquo;new&amp;rdquo; and safer language that is now made ready for embedded processors. There is a fairly active community around it.
However, apart from personal language preference, Go has a few advantages:
 Subjective, but in general Go is easier to learn. Rust is in general far more complicated than Go, with difficult-to-grasp ownership rules, traits, generics, etc. Go prides itself on being a simple and slightly dumb language, sacrificing some expressiveness for readability.</description>
    </item>
    
    <item>
      <title>Harvard architectures (AVR)</title>
      <link>https://tinygo.org/compiler-internals/harvard-arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/harvard-arch/</guid>
      <description>The AVR architecture is a modified Harvard architecture, which means that flash and RAM live in different address spaces. In practice, this means that any given pointer may either point to RAM or flash, but this is not visible from the pointer itself.
To get TinyGo to work on the Arduino, which uses the AVR architecutre, all global variables (which include string constants!) are marked non-constant and thus are stored in RAM and all pointer dereferences assume that pointers point to RAM.</description>
    </item>
    
    <item>
      <title>Microcontroller Targets</title>
      <link>https://tinygo.org/compiler-internals/microcontrollers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/microcontrollers/</guid>
      <description>TinyGo was designed to run on microcontrollers, but the Go language wasn&amp;rsquo;t. This means there are a few challenges to writing Go code for microcontrollers.
Microcontrollers have very little RAM and execute code directly from flash. Also, constant globals are generally put in flash whenever possible. The Go language itself heavily relies on garbage collection so care must be taken to avoid dynamic memory allocation.
ARM ARM Cortex-M processors are well supported.</description>
    </item>
    
    <item>
      <title>Pipeline</title>
      <link>https://tinygo.org/compiler-internals/pipeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/compiler-internals/pipeline/</guid>
      <description>Like most compilers, TinyGo is a compiler built as a pipeline of transformations that each translate an input to a simpler output version (also called lowering). However, most of these part are not in TinyGo itself. The frontend is mostly implemented by external Go libraries, and most optimizations and code generation is implemented by LLVM.
This is roughly the pipeline for TinyGo:
 Lexing, parsing, and typechecking is done by packages in the standard library and in the golang.</description>
    </item>
    
    <item>
      <title>What about the ESP8266/ESP32?</title>
      <link>https://tinygo.org/faq/what-about-esp8266-esp32/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/faq/what-about-esp8266-esp32/</guid>
      <description>These chips use the rather obscure Xtensa instruction set. While a port of GCC exists and Espressif provides precompiled GNU toolchains, there is no support yet in LLVM (although there have been multiple attempts.
There are two ways these chips might be supported in the future, and both will take a considerable amount of work:
 The compiled LLVM IR can be converted into (ugly) C and then be compiled with a supported C compiler (like GCC for Xtensa).</description>
    </item>
    
  </channel>
</rss>