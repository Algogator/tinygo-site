<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on microcontrollers on TinyGo - Go on Microcontrollers and WASM</title>
    <link>https://tinygo.org/microcontrollers/</link>
    <description>Recent content in Go on microcontrollers on TinyGo - Go on Microcontrollers and WASM</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tinygo.org/microcontrollers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Heap allocation</title>
      <link>https://tinygo.org/microcontrollers/heap-allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/heap-allocation/</guid>
      <description>Many operations in Go rely on heap allocation. Some of these heap allocations are optimized away, but not all of them. Also, TinyGo does not yet contain a garbage collector so heap allocation must be avoided whenever possible outside of initialization code.
These operations currently do heap allocations:
 Taking the pointer of a local variable. This will result in a heap allocation, unless the compiler can see the resulting pointer never escapes.</description>
    </item>
    
    <item>
      <title>The volatile keyword</title>
      <link>https://tinygo.org/microcontrollers/volatile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/volatile/</guid>
      <description>Go does not have the volatile keyword like C/C++. This keyword is unnecessary in most desktop use cases but is required for memory mapped I/O on microcontrollers and interrupt handlers. As a workaround, any variable of a type annotated with the //go:volatile pragma will be marked volatile. For example:
//go:volatile type volatileBool bool var isrFlag volatileBool  This is a workaround for a limitation in the Go language and should at some point be replaced with something else.</description>
    </item>
    
    <item>
      <title>Inline assembly</title>
      <link>https://tinygo.org/microcontrollers/inline-assembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/inline-assembly/</guid>
      <description>The device-specific packages like device/avr and device/arm provide Asm functions which you can use to write inline assembly:
arm.Asm(&amp;quot;wfi&amp;quot;)  You can also pass parameters to the inline assembly:
var result int32 arm.AsmFull(` lsls {value}, #1 str {value}, {result} `, map[string]interface{}{ &amp;quot;value&amp;quot;: 42, &amp;quot;result&amp;quot;: &amp;amp;result, }) println(&amp;quot;result:&amp;quot;, result)  In general, types are autodetected. That is, integer types are passed as raw registers and pointer types are passed as memory locations.</description>
    </item>
    
    <item>
      <title>Harvard architectures (AVR)</title>
      <link>https://tinygo.org/microcontrollers/harvard-arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tinygo.org/microcontrollers/harvard-arch/</guid>
      <description>The AVR architecture is a modified Harvard architecture, which means that flash and RAM live in different address spaces. In practice, this means that any given pointer may either point to RAM or flash, but this is not visible from the pointer itself.
To get TinyGo to work on the Arduino, which uses the AVR architecutre, all global variables (which include string constants!) are marked non-constant and thus are stored in RAM and all pointer dereferences assume that pointers point to RAM.</description>
    </item>
    
  </channel>
</rss>